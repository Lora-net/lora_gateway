/*
 / _____)             _              | |    
( (____  _____ ____ _| |_ _____  ____| |__  
 \____ \| ___ |    (_   _) ___ |/ ___)  _ \
 _____) ) ____| | | || |_| ____( (___| | | |
(______/|_____)_|_|_| \__)_____)\____)_| |_|
    ©2013 Semtech-Cycleo

Description:
    Functions used to handle a single Lora gateway.
    Registers are addressed by name.
    Multi-bytes registers are handled automatically.
    Read-modify-write is handled automatically.
*/


/* -------------------------------------------------------------------------- */
/* --- DEPENDANCIES --------------------------------------------------------- */

#include <stdint.h>     /* C99 types */
#include <stdbool.h>    /* bool type */
#include <stdio.h>      /* printf fprintf */

#include "loragw_spi.h"
#include "loragw_reg.h"

/* -------------------------------------------------------------------------- */
/* --- PRIVATE MACROS ------------------------------------------------------- */

#define ARRAY_SIZE(a) (sizeof(a) / sizeof((a)[0]))
#ifdef DEBUG
    #define DEBUG_MSG(str)              fprintf(stderr, str)
    #define DEBUG_PRINTF(fmt, args...)  fprintf(stderr,"%s:%d: "fmt, __FUNCTION__, __LINE__, args)
    #define CHECK_NULL(a)               if(a==NULL){fprintf(stderr,"%s:%d: ERROR: NULL POINTER AS ARGUMENT\n", __FUNCTION__, __LINE__);return LGW_REG_ERROR;}
#else
    #define DEBUG_MSG(str)
    #define DEBUG_PRINTF(fmt, args...)
    #define CHECK_NULL(a)               if(a==NULL){return LGW_REG_ERROR;}
#endif

/* -------------------------------------------------------------------------- */
/* --- PRIVATE TYPES -------------------------------------------------------- */

struct lgw_reg_s {
    int8_t      page;       /*!< page containing the register (-1 for all pages) */
    uint8_t     addr;       /*!< base address of the register (7 bit) */
    uint8_t     offs;       /*!< position of the register LSB (between 0 to 7) */
    bool        sign;       /*!< 1 indicates the register is signed (2 complem.) */
    uint8_t     leng;       /*!< number of bits in the register */
    char        name[40];   /*!< name of the register */
    bool        rdon;       /*!< 1 indicates a read-only register */
    int32_t     dflt;       /*!< register default value */
};

/* -------------------------------------------------------------------------- */
/* --- PRIVATE CONSTANTS ---------------------------------------------------- */

#define PAGE_ADDR       0x00    
#define PAGE_MASK       0x03

/*
auto generated register mapping for C code : 24-Jun-2013 20:29:09
this file contains autogenerated C struct used to access the LORA register from the Primer firmware
this file is autogenerated from registers description
290 registers are defined
*/
const struct lgw_reg_s loregs[LGW_TOTALREGS] = {
    {-1,0,0,0,2,"PAGE_REG",0,0},
    {-1,0,7,0,1,"SOFT_RESET",0,0},
    {-1,1,0,0,8,"VERSION",1,100},
    {-1,2,0,0,16,"RX_DATA_BUF_ADDR",0,0},
    {-1,4,0,0,8,"RX_DATA_BUF_DATA",1,0},
    {-1,5,0,0,8,"TX_DATA_BUF_ADDR",0,0},
    {-1,6,0,0,8,"TX_DATA_BUF_DATA",0,0},
    {-1,7,0,0,8,"CAPTURE_RAM_ADDR",0,0},
    {-1,8,0,0,8,"CAPTURE_RAM_DATA",1,0},
    {-1,9,0,0,8,"MCU_PROM_ADDR",0,0},
    {-1,10,0,0,8,"MCU_PROM_DATA",0,0},
    {-1,11,0,0,8,"RX_PACKET_DATA_FIFO_NUM_STORED",0,0},
    {-1,12,0,0,16,"RX_PACKET_DATA_FIFO_ADDR_POINTER",1,0},
    {-1,14,0,0,8,"RX_PACKET_DATA_FIFO_STATUS",1,0},
    {-1,15,0,0,8,"RX_PACKET_DATA_FIFO_PAYLOAD_SIZE",1,0},
    {-1,16,0,0,1,"MBWSSF_MODEM_ENABLE",0,0},
    {-1,16,1,0,1,"CONCENTRATOR_MODEM_ENABLE",0,0},
    {-1,16,2,0,1,"FSK_MODEM_ENABLE",0,0},
    {-1,17,0,0,1,"CLK32M_EN",0,0},
    {-1,17,1,0,1,"CLKHS_EN",0,0},
    {-1,18,0,0,1,"START_BIST0",0,0},
    {-1,18,1,0,1,"START_BIST1",0,0},
    {-1,18,2,0,1,"CLEAR_BIST0",0,0},
    {-1,18,3,0,1,"CLEAR_BIST1",0,0},
    {-1,19,0,0,1,"BIST0_FINISHED",1,0},
    {-1,19,1,0,1,"BIST1_FINISHED",1,0},
    {-1,20,0,0,1,"MCU_AGC_PROG_RAM_BIST_STATUS",1,0},
    {-1,20,1,0,1,"MCU_ARB_PROG_RAM_BIST_STATUS",1,0},
    {-1,20,2,0,1,"CAPTURE_RAM_BIST_STATUS",1,0},
    {-1,20,3,0,1,"CHAN_FIR_RAM0_BIST_STATUS",1,0},
    {-1,20,4,0,1,"CHAN_FIR_RAM1_BIST_STATUS",1,0},
    {-1,21,0,0,1,"CORR0_RAM_BIST_STATUS",1,0},
    {-1,21,1,0,1,"CORR1_RAM_BIST_STATUS",1,0},
    {-1,21,2,0,1,"CORR2_RAM_BIST_STATUS",1,0},
    {-1,21,3,0,1,"CORR3_RAM_BIST_STATUS",1,0},
    {-1,21,4,0,1,"CORR4_RAM_BIST_STATUS",1,0},
    {-1,21,5,0,1,"CORR5_RAM_BIST_STATUS",1,0},
    {-1,21,6,0,1,"CORR6_RAM_BIST_STATUS",1,0},
    {-1,21,7,0,1,"CORR7_RAM_BIST_STATUS",1,0},
    {-1,22,0,0,1,"MODEM0_RAM0_BIST_STATUS",1,0},
    {-1,22,1,0,1,"MODEM1_RAM0_BIST_STATUS",1,0},
    {-1,22,2,0,1,"MODEM2_RAM0_BIST_STATUS",1,0},
    {-1,22,3,0,1,"MODEM3_RAM0_BIST_STATUS",1,0},
    {-1,22,4,0,1,"MODEM4_RAM0_BIST_STATUS",1,0},
    {-1,22,5,0,1,"MODEM5_RAM0_BIST_STATUS",1,0},
    {-1,22,6,0,1,"MODEM6_RAM0_BIST_STATUS",1,0},
    {-1,22,7,0,1,"MODEM7_RAM0_BIST_STATUS",1,0},
    {-1,23,0,0,1,"MODEM0_RAM1_BIST_STATUS",1,0},
    {-1,23,1,0,1,"MODEM1_RAM1_BIST_STATUS",1,0},
    {-1,23,2,0,1,"MODEM2_RAM1_BIST_STATUS",1,0},
    {-1,23,3,0,1,"MODEM3_RAM1_BIST_STATUS",1,0},
    {-1,23,4,0,1,"MODEM4_RAM1_BIST_STATUS",1,0},
    {-1,23,5,0,1,"MODEM5_RAM1_BIST_STATUS",1,0},
    {-1,23,6,0,1,"MODEM6_RAM1_BIST_STATUS",1,0},
    {-1,23,7,0,1,"MODEM7_RAM1_BIST_STATUS",1,0},
    {-1,24,0,0,1,"MODEM0_RAM2_BIST_STATUS",1,0},
    {-1,24,1,0,1,"MODEM1_RAM2_BIST_STATUS",1,0},
    {-1,24,2,0,1,"MODEM2_RAM2_BIST_STATUS",1,0},
    {-1,24,3,0,1,"MODEM3_RAM2_BIST_STATUS",1,0},
    {-1,24,4,0,1,"MODEM4_RAM2_BIST_STATUS",1,0},
    {-1,24,5,0,1,"MODEM5_RAM2_BIST_STATUS",1,0},
    {-1,24,6,0,1,"MODEM6_RAM2_BIST_STATUS",1,0},
    {-1,24,7,0,1,"MODEM7_RAM2_BIST_STATUS",1,0},
    {-1,25,0,0,1,"MODEM_MBWSSF_RAM0_BIST_STATUS",1,0},
    {-1,25,1,0,1,"MODEM_MBWSSF_RAM1_BIST_STATUS",1,0},
    {-1,25,2,0,1,"MODEM_MBWSSF_RAM2_BIST_STATUS",1,0},
    {-1,26,0,0,1,"MCU_AGC_DATA_RAM_BIST0_STATUS",1,0},
    {-1,26,1,0,1,"MCU_AGC_DATA_RAM_BIST1_STATUS",1,0},
    {-1,26,2,0,1,"MCU_ARB_DATA_RAM_BIST0_STATUS",1,0},
    {-1,26,3,0,1,"MCU_ARB_DATA_RAM_BIST1_STATUS",1,0},
    {-1,26,4,0,1,"TX_TOP_RAM_BIST0_STATUS",1,0},
    {-1,26,5,0,1,"TX_TOP_RAM_BIST1_STATUS",1,0},
    {-1,26,6,0,1,"DATA_MNGT_RAM_BIST0_STATUS",1,0},
    {-1,26,7,0,1,"DATA_MNGT_RAM_BIST1_STATUS",1,0},
    {-1,27,0,0,8,"GPIO_SELECT",0,0},
    {-1,28,0,0,8,"GPIO_MUX",0,0},
    {-1,127,0,0,1,"EMERGENCY_FORCE_HOST_CTRL",0,0},
    {0,29,0,0,1,"RX_INVERT_IQ",0,0},
    {0,29,1,0,1,"MODEM_INVERT_IQ",0,1},
    {0,29,2,0,1,"MBWSSF_MODEM_INVERT_IQ",0,0},
    {0,29,3,0,1,"RX_EDGE_SELECT",0,0},
    {0,29,4,0,1,"MISC_RADIO_EN",0,0},
    {0,30,0,0,4,"FILTER_GAIN",0,7},
    {0,31,0,0,8,"RADIO_SELECT",0,240},
    {0,32,0,1,13,"IF_FREQ_0",0,-384},
    {0,34,0,1,13,"IF_FREQ_1",0,-128},
    {0,36,0,1,13,"IF_FREQ_2",0,128},
    {0,38,0,1,13,"IF_FREQ_3",0,384},
    {0,40,0,1,13,"IF_FREQ_4",0,-384},
    {0,42,0,1,13,"IF_FREQ_5",0,-128},
    {0,44,0,1,13,"IF_FREQ_6",0,128},
    {0,46,0,1,13,"IF_FREQ_7",0,384},
    {0,48,0,1,13,"IF_FREQ_8",0,0},
    {0,50,0,1,13,"IF_FREQ_9",0,0},
    {0,60,0,0,1,"CHANN_OVERRIDE_AGC_GAIN",0,0},
    {0,60,1,0,4,"CHANN_AGC_GAIN",0,7},
    {0,61,0,0,7,"CORR0_DETECT_EN",0,0},
    {0,62,0,0,7,"CORR1_DETECT_EN",0,0},
    {0,63,0,0,7,"CORR2_DETECT_EN",0,0},
    {0,64,0,0,7,"CORR3_DETECT_EN",0,0},
    {0,65,0,0,7,"CORR4_DETECT_EN",0,0},
    {0,66,0,0,7,"CORR5_DETECT_EN",0,0},
    {0,67,0,0,7,"CORR6_DETECT_EN",0,0},
    {0,68,0,0,7,"CORR7_DETECT_EN",0,0},
    {0,69,0,0,1,"CORR_SAME_PEAKS_OPTION_SF6",0,0},
    {0,69,1,0,1,"CORR_SAME_PEAKS_OPTION_SF7",0,1},
    {0,69,2,0,1,"CORR_SAME_PEAKS_OPTION_SF8",0,1},
    {0,69,3,0,1,"CORR_SAME_PEAKS_OPTION_SF9",0,1},
    {0,69,4,0,1,"CORR_SAME_PEAKS_OPTION_SF10",0,1},
    {0,69,5,0,1,"CORR_SAME_PEAKS_OPTION_SF11",0,1},
    {0,69,6,0,1,"CORR_SAME_PEAKS_OPTION_SF12",0,1},
    {0,70,0,0,4,"CORR_SIG_NOISE_RATIO_SF6",0,4},
    {0,70,4,0,4,"CORR_SIG_NOISE_RATIO_SF7",0,4},
    {0,71,0,0,4,"CORR_SIG_NOISE_RATIO_SF8",0,4},
    {0,71,4,0,4,"CORR_SIG_NOISE_RATIO_SF9",0,4},
    {0,72,0,0,4,"CORR_SIG_NOISE_RATIO_SF10",0,4},
    {0,72,4,0,4,"CORR_SIG_NOISE_RATIO_SF11",0,4},
    {0,73,0,0,4,"CORR_SIG_NOISE_RATIO_SF12",0,4},
    {0,74,0,0,4,"CORR_NUM_SAME_PEAK",0,4},
    {0,74,4,0,3,"CORR_MAC_GAIN",0,5},
    {0,75,0,0,12,"ADJUST_MODEM_START_OFFSET_RDX8",0,0},
    {0,77,0,0,12,"ADJUST_MODEM_START_OFFSET_RDX4",0,0},
    {0,79,0,0,12,"ADJUST_MODEM_START_OFFSET_SF12_RDX4",0,4092},
    {0,81,0,0,8,"DBG_CORR_SELECT_SF",0,7},
    {0,82,0,0,8,"DBG_CORR_SELECT_CHANNEL",0,0},
    {0,83,0,0,8,"DBG_DETECT_CPT",1,0},
    {0,84,0,0,8,"DBG_SYMB_CPT",1,0},
    {0,85,0,0,1,"CHIRP_INVERT_RX",0,1},
    {0,85,1,0,1,"DC_NOTCH_EN",0,0},
    {0,86,0,0,1,"IMPLICIT_CRC_EN",0,0},
    {0,86,1,0,3,"IMPLICIT_CODING_RATE",0,0},
    {0,87,0,0,8,"IMPLICIT_PAYLOAD_LENGHT",0,0},
    {0,88,0,0,8,"FREQ_TO_TIME_INVERT",0,29},
    {0,89,0,0,6,"FREQ_TO_TIME_DRIFT",0,9},
    {0,90,0,0,2,"PAYLOAD_FINE_TIMING_GAIN",0,2},
    {0,90,2,0,2,"PREAMBLE_FINE_TIMING_GAIN",0,1},
    {0,90,4,0,2,"TRACKING_INTEGRAL",0,0},
    {0,91,0,0,4,"FRAME_SYNCH_PEAK1_POS",0,1},
    {0,91,4,0,4,"FRAME_SYNCH_PEAK2_POS",0,2},
    {0,92,0,0,16,"PREAMBLE_SYMB1_NB",0,10},
    {0,94,0,0,1,"FRAME_SYNCH_GAIN",0,1},
    {0,94,1,0,1,"SYNCH_DETECT_TH",0,1},
    {0,95,0,0,4,"LLR_SCALE",0,8},
    {0,95,4,0,2,"SNR_AVG_CST",0,2},
    {0,96,0,0,7,"PPM_OFFSET",0,0},
    {0,97,0,0,8,"MAX_PAYLOAD_LEN",0,255},
    {0,98,0,0,1,"ONLY_CRC_EN",0,1},
    {0,99,0,0,8,"ZERO_PAD",0,0},
    {0,100,0,0,4,"DEC_GAIN_OFFSET",0,8},
    {0,101,0,0,1,"FORCE_HOST_REG_CTRL",0,1},
    {0,101,1,0,1,"FORCE_HOST_RADIO_CTRL",0,1},
    {0,101,2,0,1,"FORCE_HOST_FE_CTRL",0,1},
    {0,101,3,0,1,"FORCE_DEC_FILTER_GAIN",0,1},
    {0,102,0,0,1,"MCU_RST_0",0,1},
    {0,102,1,0,1,"MCU_RST_1",0,1},
    {0,102,2,0,1,"MCU_SELECT_MUX_0",0,0},
    {0,102,3,0,1,"MCU_SELECT_MUX_1",0,0},
    {0,102,4,0,1,"MCU_CORRUPTION_DETECTED_0",1,0},
    {0,102,5,0,1,"MCU_CORRUPTION_DETECTED_1",1,0},
    {0,103,0,0,8,"CHANN_SELECT_RSSI",0,1},
    {0,104,0,0,8,"RSSI_BB_DEFAULT_VALUE",0,32},
    {0,105,0,0,8,"RSSI_DEC_DEFAULT_VALUE",0,100},
    {0,106,0,0,8,"RSSI_CHANN_DEFAULT_VALUE",0,100},
    {0,107,0,0,5,"RSSI_BB_FILTER_ALPHA",0,7},
    {0,108,0,0,5,"RSSI_DEC_FILTER_ALPHA",0,5},
    {0,109,0,0,5,"RSSI_CHANN_FILTER_ALPHA",0,8},
    {0,110,0,0,6,"IQ_MISMATCH_A_AMP_COEFF",0,0},
    {0,111,0,0,6,"IQ_MISMATCH_A_PHI_COEFF",0,0},
    {0,112,0,0,6,"IQ_MISMATCH_B_AMP_COEFF",0,0},
    {0,112,6,0,1,"IQ_MISMATCH_B_SEL_I",0,0},
    {0,113,0,0,6,"IQ_MISMATCH_B_PHI_COEFF",0,0},
    {1,29,0,0,1,"TX_TRIG_IMMEDIATE",0,0},
    {1,29,1,0,1,"TX_TRIG_DELAYED",0,0},
    {1,29,2,0,1,"TX_TRIG_GPS",0,0},
    {1,30,0,0,16,"TX_START_DELAY",0,0},
    {1,32,0,0,4,"TX_FRAME_SYNCH_PEAK1_POS",0,1},
    {1,32,4,0,4,"TX_FRAME_SYNCH_PEAK2_POS",0,2},
    {1,33,0,0,16,"TX_PREAMBLE_SYMB1_NB",0,10},
    {1,35,0,0,8,"TX_OFFSET_I",0,0},
    {1,36,0,0,8,"TX_OFFSET_Q",0,0},
    {1,37,0,0,1,"TX_MODE",0,0},
    {1,37,1,0,4,"TX_ZERO_PAD",0,0},
    {1,37,5,0,1,"TX_PPM_OFFSET",0,0},
    {1,37,6,0,1,"TX_CHIRP_INVERT",0,0},
    {1,37,7,0,1,"TX_CONT_CHIRP",0,0},
    {1,38,0,0,2,"TX_GAIN",0,0},
    {1,38,2,0,3,"TX_CHIRP_LOW_PASS",0,0},
    {1,38,5,0,2,"TX_FCC_WIDEBAND",0,0},
    {1,38,7,0,1,"TX_SWAP_IQ",0,0},
    {1,39,0,0,1,"MBWSSF_IMPLICIT_HEADER",0,0},
    {1,39,1,0,1,"MBWSSF_IMPLICIT_CRC_EN",0,0},
    {1,39,2,0,3,"MBWSSF_IMPLICIT_CODING_RATE",0,0},
    {1,40,0,0,8,"MBWSSF_IMPLICIT_PAYLOAD_LENGHT",0,0},
    {1,41,0,0,1,"MBWSSF_AGC_FREEZE_ON_DETECT",0,1},
    {1,42,0,0,4,"MBWSSF_FRAME_SYNCH_PEAK1_POS",0,1},
    {1,42,4,0,4,"MBWSSF_FRAME_SYNCH_PEAK2_POS",0,2},
    {1,43,0,0,16,"MBWSSF_PREAMBLE_SYMB1_NB",0,10},
    {1,45,0,0,1,"MBWSSF_FRAME_SYNCH_GAIN",0,1},
    {1,45,1,0,1,"MBWSSF_SYNCH_DETECT_TH",0,1},
    {1,46,0,0,8,"MBWSSF_DETECT_MIN_SINGLE_PEAK",0,10},
    {1,47,0,0,3,"MBWSSF_DETECT_TRIG_SAME_PEAK_NB",0,3},
    {1,48,0,0,8,"MBWSSF_FREQ_TO_TIME_INVERT",0,29},
    {1,49,0,0,6,"MBWSSF_FREQ_TO_TIME_DRIFT",0,36},
    {1,50,0,0,12,"MBWSSF_PPM_CORRECTION",0,0},
    {1,52,0,0,2,"MBWSSF_PAYLOAD_FINE_TIMING_GAIN",0,2},
    {1,52,2,0,2,"MBWSSF_PREAMBLE_FINE_TIMING_GAIN",0,1},
    {1,52,4,0,2,"MBWSSF_TRACKING_INTEGRAL",0,0},
    {1,53,0,0,8,"MBWSSF_ZERO_PAD",0,0},
    {1,54,0,0,2,"MBWSSF_MODEM_BW",0,0},
    {1,54,2,0,1,"MBWSSF_RADIO_SELECT",0,0},
    {1,54,3,0,1,"MBWSSF_RX_CHIRP_INVERT",0,1},
    {1,55,0,0,4,"MBWSSF_LLR_SCALE",0,8},
    {1,55,4,0,2,"MBWSSF_SNR_AVG_CST",0,3},
    {1,55,6,0,1,"MBWSSF_PPM_OFFSET",0,0},
    {1,56,0,0,4,"MBWSSF_RATE_SF",0,7},
    {1,56,4,0,1,"MBWSSF_ONLY_CRC_EN",0,1},
    {1,57,0,0,8,"MBWSSF_MAX_PAYLOAD_LEN",0,255},
    {2,29,0,0,8,"SPI_RADIO_A__DATA",0,0},
    {2,30,0,0,8,"SPI_RADIO_A__DATA_READBACK",1,0},
    {2,31,0,0,14,"SPI_RADIO_A__ADDR",0,0},
    {2,33,0,0,1,"SPI_RADIO_A__CS",0,0},
    {2,34,0,0,8,"SPI_RADIO_B__DATA",0,0},
    {2,35,0,0,8,"SPI_RADIO_B__DATA_READBACK",1,0},
    {2,36,0,0,14,"SPI_RADIO_B__ADDR",0,0},
    {2,38,0,0,1,"SPI_RADIO_B__CS",0,0},
    {2,39,0,0,1,"RADIO_A_EN",0,0},
    {2,39,1,0,1,"RADIO_B_EN",0,0},
    {2,39,2,0,1,"RADIO_RST",0,1},
    {2,39,3,0,1,"LNA_A_EN",0,0},
    {2,39,4,0,1,"PA_A_EN",0,0},
    {2,39,5,0,1,"LNA_B_EN",0,0},
    {2,39,6,0,1,"PA_B_EN",0,0},
    {2,40,0,0,2,"PA_A_GAIN",0,0},
    {2,40,2,0,2,"PA_B_GAIN",0,0},
    {2,41,0,0,4,"LNA_A_CTRL_LUT",0,2},
    {2,41,4,0,4,"PA_A_CTRL_LUT",0,4},
    {2,42,0,0,4,"LNA_B_CTRL_LUT",0,2},
    {2,42,4,0,4,"PA_B_CTRL_LUT",0,4},
    {2,43,0,0,5,"CAPTURE_SOURCE",0,0},
    {2,43,5,0,1,"CAPTURE_START",0,0},
    {2,43,6,0,1,"CAPTURE_FORCE_TRIGGER",0,0},
    {2,43,7,0,1,"CAPTURE_WRAP",0,0},
    {2,44,0,0,16,"CAPTURE_PERIOD",0,0},
    {2,46,0,0,3,"LED_REG",0,3},
    {2,47,0,0,8,"MODEM_STATUS",1,0},
    {2,48,0,0,8,"VALID_HEADER_COUNTER_0",1,0},
    {2,49,0,0,8,"VALID_HEADER_COUNTER_1",1,0},
    {2,50,0,0,8,"VALID_PACKET_COUNTER_0",1,0},
    {2,51,0,0,8,"VALID_PACKET_COUNTER_1",1,0},
    {2,52,0,0,8,"VALID_HEADER_COUNTER_MBWSSF",1,0},
    {2,53,0,0,8,"VALID_HEADER_COUNTER_FSK",1,0},
    {2,54,0,0,8,"VALID_PACKET_COUNTER_MBWSSF",1,0},
    {2,55,0,0,8,"VALID_PACKET_COUNTER_FSK",1,0},
    {2,56,0,0,8,"CHANN_RSSI",1,0},
    {2,57,0,0,8,"BB_RSSI",1,0},
    {2,58,0,0,8,"DEC_RSSI",1,0},
    {2,59,0,0,8,"DBG_MCU_DATA",1,0},
    {2,60,0,0,8,"DBG_ARB_MCU_RAM_DATA",1,0},
    {2,61,0,0,8,"DBG_AGC_MCU_RAM_DATA",1,0},
    {2,62,0,0,16,"NEXT_PACKET_CNT",1,0},
    {2,64,0,0,16,"ADDR_CAPTURE_COUNT",1,0},
    {2,66,0,0,32,"TIMESTAMP",1,0},
    {2,70,0,0,4,"DBG_CHANN0_GAIN",1,0},
    {2,70,4,0,4,"DBG_CHANN1_GAIN",1,0},
    {2,71,0,0,4,"DBG_CHANN2_GAIN",1,0},
    {2,71,4,0,4,"DBG_CHANN3_GAIN",1,0},
    {2,72,0,0,4,"DBG_CHANN4_GAIN",1,0},
    {2,72,4,0,4,"DBG_CHANN5_GAIN",1,0},
    {2,73,0,0,4,"DBG_CHANN6_GAIN",1,0},
    {2,73,4,0,4,"DBG_CHANN7_GAIN",1,0},
    {2,74,0,0,4,"DBG_DEC_FILT_GAIN",1,0},
    {2,75,0,0,3,"SPI_DATA_FIFO_PTR",1,0},
    {2,75,3,0,3,"PACKET_DATA_FIFO_PTR",1,0},
    {2,76,0,0,8,"DBG_ARB_MCU_RAM_ADDR",0,0},
    {2,77,0,0,8,"DBG_AGC_MCU_RAM_ADDR",0,0},
    {2,78,0,0,1,"SPI_MASTER_CHIP_SELECT_POLARITY",0,0},
    {2,78,1,0,1,"SPI_MASTER_CPOL",0,0},
    {2,78,2,0,1,"SPI_MASTER_CPHA",0,0},
    {2,79,0,0,1,"SIG_GEN_ANALYSER_MUX_SEL",0,0},
    {2,80,0,0,1,"SIG_GEN_EN",0,0},
    {2,80,1,0,1,"SIG_ANALYSER_EN",0,0},
    {2,80,2,0,2,"SIG_ANALYSER_AVG_LEN",0,0},
    {2,80,4,0,3,"SIG_ANALYSER_PRECISION",0,0},
    {2,80,7,0,1,"SIG_ANALYSER_VALID_OUT",1,0},
    {2,81,0,0,8,"SIG_GEN_FREQ",0,0},
    {2,82,0,0,8,"SIG_ANALYSER_FREQ",0,0},
    {2,83,0,0,8,"SIG_ANALYSER_I_OUT",1,0},
    {2,84,0,0,8,"SIG_ANALYSER_Q_OUT",1,0},
    {2,85,0,0,1,"GPS_EN",0,0},
    {2,85,1,0,1,"GPS_POL",0,1}
};

/* -------------------------------------------------------------------------- */
/* --- PRIVATE VARIABLES ---------------------------------------------------- */

static int lgw_spidesc = -1; /*! file descriptor to the SPI device */
static int lgw_regpage = -1; /*! keep the value of the register page selected */

/* -------------------------------------------------------------------------- */
/* --- PRIVATE FUNCTIONS ---------------------------------------------------- */

int page_switch(uint8_t target) {
    lgw_regpage = PAGE_MASK & target;
    lgw_spi_w(lgw_spidesc, PAGE_ADDR, (uint8_t)lgw_regpage);
    return LGW_REG_SUCCESS;
}

/* -------------------------------------------------------------------------- */
/* --- PUBLIC FUNCTIONS DEFINITION ------------------------------------------ */

/* Gateway connect */
int lgw_connect(void) {
    int spi_stat = LGW_SPI_SUCCESS;
    uint8_t u = 0;
    
    if (lgw_spidesc >= 0) {
        DEBUG_MSG("WARNING: gateway was already connected\n");
        lgw_spi_close(lgw_spidesc);
    }
    /* open the SPI link */
    spi_stat = lgw_spi_open(&lgw_spidesc);
    if (spi_stat != LGW_SPI_SUCCESS) {
        DEBUG_MSG("ERROR CONNECTING GATEWAY\n");
        return LGW_REG_ERROR;
    }
    /* write 0 to the page/reset register */
    spi_stat = lgw_spi_w(lgw_spidesc, loregs[LGW_PAGE_REG].addr, 0);
    if (spi_stat != LGW_SPI_SUCCESS) {
        DEBUG_MSG("ERROR WRITING PAGE REGISTER\n");
        return LGW_REG_ERROR;
    } else {
        lgw_regpage = 0;
    }
    /* checking the version register */
    spi_stat = lgw_spi_r(lgw_spidesc, loregs[LGW_VERSION].addr, &u);
    if (spi_stat != LGW_SPI_SUCCESS) {
        DEBUG_MSG("ERROR READING VERSION REGISTER\n");
        return LGW_REG_ERROR;
    } else if (u == 0) {
        DEBUG_MSG("ERROR: GATEWAY SEEMS DISCONNECTED\n");
        return LGW_REG_ERROR;
    } else if (u != loregs[LGW_VERSION].dflt) {
        DEBUG_MSG("ERROR: MISMATCH BETWEEN EXPECTED REG VERSION AND READ REG VERSION\n");
        return LGW_REG_ERROR;
    }
    DEBUG_MSG("Note: success connecting the gateway\n");
    return LGW_REG_SUCCESS;
}

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

/* Gateway disconnect */
int lgw_disconnect(void) {
    if (lgw_spidesc >= 0) {
        lgw_spi_close(lgw_spidesc);
        lgw_spidesc = -1;
        DEBUG_MSG("Note: success disconnecting the gateway\n");
        return LGW_REG_SUCCESS;
    } else {
        DEBUG_MSG("WARNING: gateway was already disconnected\n");
        lgw_spidesc = -1;
        return LGW_REG_ERROR;
    }
}

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

/* soft-reset function */
int lgw_soft_reset(void) {
    int32_t read_value;
    /* check if SPI is initialised */
    if ((lgw_spidesc < 0) || (lgw_regpage < 0)) {
        DEBUG_MSG("ERROR: GATEWAY UNCONNECTED\n");
        return LGW_REG_ERROR;
    }
    lgw_spi_w(lgw_spidesc, 0, 0x80); /* 1 -> SOFT_RESET bit */
    lgw_regpage = 0; /* reset the paging static variable */
    return LGW_REG_SUCCESS;
}

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

/* register verification */
int lgw_reg_check(FILE *f) {
    struct lgw_reg_s r;
    int32_t read_value;
    char ok_msg[] = "+++MATCH+++";
    char notok_msg[] = "###MISMATCH###";
    char *ptr;
    int i;
    
    /* check if SPI is initialised */
    if ((lgw_spidesc < 0) || (lgw_regpage < 0)) {
        DEBUG_MSG("ERROR: GATEWAY UNCONNECTED\n");
        fprintf(f, "ERROR: GATEWAY UNCONNECTED\n");
        return LGW_REG_ERROR;
    }
    
    fprintf(f, "Start of register verification\n");
    for (i=0; i<LGW_TOTALREGS; ++i) {
        r = loregs[i];
        lgw_reg_r(i, &read_value);
        ptr = (read_value == r.dflt) ? ok_msg : notok_msg;
        if (r.sign == true)
            fprintf(f, "%s reg: %s read: %d (%x) default: %d (%x)\n", ptr, r.name, read_value, read_value, r.dflt, r.dflt);
        else
            fprintf(f, "%s reg: %s read: %u (%x) default: %u (%x)\n", ptr, r.name, read_value, read_value, r.dflt, r.dflt);
    }
    fprintf(f, "End of register verification\n");
    
    return LGW_REG_SUCCESS;
}

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

/* Write to a register addressed by name */
int lgw_reg_w(uint16_t register_id, int32_t reg_value) {
    int spi_stat = LGW_SPI_SUCCESS;
    struct lgw_reg_s r;
    uint8_t buf[4] = "\x00\x00\x00\x00";
    int i, size_byte;
    
    /* check input parameters */
    if (register_id >= LGW_TOTALREGS) {
        DEBUG_MSG("ERROR: REGISTER NUMBER OUT OF DEFINED RANGE\n");
        return LGW_REG_ERROR;
    }
    
    /* check if SPI is initialised */
    if ((lgw_spidesc < 0) || (lgw_regpage < 0)) {
        DEBUG_MSG("ERROR: GATEWAY UNCONNECTED\n");
        return LGW_REG_ERROR;
    }
    
    /* intercept direct access to PAGE_REG & SOFT_RESET */
    if (register_id == LGW_PAGE_REG) {
        page_switch(reg_value);
        return LGW_REG_SUCCESS;
    } else if (register_id == LGW_SOFT_RESET) {
        /* only reset if lsb is 1 */
        if (reg_value%2 != 0)
            lgw_soft_reset();
        return LGW_REG_SUCCESS;
    }
    
    /* get register struct from the struct array */
    r = loregs[register_id];
    
    /* reject write to read-only registers */
    if (r.rdon == 1){
        DEBUG_MSG("ERROR: TRYING TO WRITE A READ-ONLY REGISTER\n");
        return LGW_REG_ERROR;
    }
    
    /* select proper register page if needed */
    if ((r.page != -1) && (r.page != lgw_regpage)) {
        spi_stat += page_switch(r.page);
    }
    
    if ((r.leng == 8) && (r.offs == 0)) {
        /* direct write */
        spi_stat += lgw_spi_w(lgw_spidesc, r.addr, (uint8_t)reg_value);
    } else if ((r.offs + r.leng) <= 8) {
        /* single-byte read-modify-write, offs:[0-7], leng:[1-7] */
        spi_stat += lgw_spi_r(lgw_spidesc, r.addr, &buf[0]);
        buf[1] = ((1 << r.leng) - 1) << r.offs; /* bit mask */
        buf[2] = ((uint8_t)reg_value) << r.offs; /* new data offsetted */
        buf[3] = (~buf[1] & buf[0]) | (buf[1] & buf[2]); /* mixing old & new data */
        spi_stat += lgw_spi_w(lgw_spidesc, r.addr, buf[3]);
    } else if ((r.offs == 0) && (r.leng > 0) && (r.leng <= 32)) {
        /* multi-byte direct write routine */
        size_byte = (r.leng + 7) / 8; /* add a byte if it's not an exact multiple of 8 */ 
        for (i=0; i<size_byte; ++i) {
            /* big endian register file for a file on N bytes
            Least significant byte is stored in buf[0], most one in buf[N-1] */
            buf[i] = (uint8_t)(0x000000FF & reg_value);
            reg_value = (reg_value >> 8);
        }
        spi_stat += lgw_spi_wb(lgw_spidesc, r.addr, buf, size_byte); /* write the register in one burst */
    } else {
        /* register spanning multiple memory bytes but with an offset */
        DEBUG_MSG("ERROR: REGISTER SIZE AND OFFSET ARE NOT SUPPORTED\n");
        return LGW_REG_ERROR;
    }
    
    if (spi_stat != LGW_SPI_SUCCESS) {
        DEBUG_MSG("ERROR: SPI ERROR DURING REGISTER WRITE\n");
        return LGW_REG_ERROR;
    } else {
        return LGW_REG_SUCCESS;
    }
}

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

/* Read to a register addressed by name */
int lgw_reg_r(uint16_t register_id, int32_t *reg_value) {
    int spi_stat = LGW_SPI_SUCCESS;
    struct lgw_reg_s r;
    uint8_t bufu[4] = "\x00\x00\x00\x00";
    int8_t *bufs = bufu;
    int i, size_byte;
    uint32_t u = 0;
    
    /* check input parameters */
    CHECK_NULL(reg_value);
    if (register_id >= LGW_TOTALREGS) {
        DEBUG_MSG("ERROR: REGISTER NUMBER OUT OF DEFINED RANGE\n");
        return LGW_REG_ERROR;
    }
    
    /* check if SPI is initialised */
    if ((lgw_spidesc < 0) || (lgw_regpage < 0)) {
        DEBUG_MSG("ERROR: GATEWAY UNCONNECTED\n");
        return LGW_REG_ERROR;
    }
    
    /* get register struct from the struct array */
    r = loregs[register_id];
    
    /* select proper register page if needed */
    if ((r.page != -1) && (r.page != lgw_regpage)) {
        spi_stat += page_switch(r.page);
    }
    
    if ((r.offs + r.leng) <= 8) {
        /* read one byte, then shift and mask bits to get reg value with sign extension if needed */
        spi_stat += lgw_spi_r(lgw_spidesc, r.addr, &bufu[0]);
        bufu[1] = bufu[0] << (8 - r.leng - r.offs); /* left-align the data */
        if (r.sign == true) {
            bufs[2] = bufs[1] >> (8 - r.leng); /* right align the data with sign extension */
            *reg_value = (int32_t)bufs[2]; /* signed pointer -> 32b sign extension */
        } else {
            bufu[2] = bufu[1] >> (8 - r.leng); /* right align the data, no sign extension */
            *reg_value = (int32_t)bufu[2]; /* unsigned pointer -> no sign extension */
        }
    } else if ((r.offs == 0) && (r.leng > 0) && (r.leng <= 32)) {
        size_byte = (r.leng + 7) / 8; /* add a byte if it's not an exact multiple of 8 */ 
        spi_stat += lgw_spi_rb(lgw_spidesc, r.addr, bufu, size_byte);
        u = 0;
        for (i=(size_byte-1); i>=0; --i) {
            u = (uint32_t)bufu[i] + (u << 8); /* transform a 4-byte array into a 32 bit word */
        }
        if (r.sign == true) {
            u = u << (32 - r.leng); /* left-align the data */
            *reg_value = (int32_t)u >> (32 - r.leng); /* right-align the data with sign extension */
        } else {
            *reg_value = (int32_t)u; /* unsigned value -> return 'as is' */
        }
    } else {
        /* register spanning multiple memory bytes but with an offset */
        DEBUG_MSG("ERROR: REGISTER SIZE AND OFFSET ARE NOT SUPPORTED\n");
        return LGW_REG_ERROR;
    }
    
    if (spi_stat != LGW_SPI_SUCCESS) {
        DEBUG_MSG("ERROR: SPI ERROR DURING REGISTER WRITE\n");
        return LGW_REG_ERROR;
    } else {
        return LGW_REG_SUCCESS;
    }
}

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

/* Point to a register by name and do a burst write */
int lgw_reg_wb(uint16_t register_id, uint8_t *data, uint16_t size) {
    int spi_stat;
    struct lgw_reg_s r;
    
    /* check input parameters */
    CHECK_NULL(data);
    if (size == 0) {
        DEBUG_MSG("ERROR: BURST OF NULL LENGTH\n");
        return LGW_REG_ERROR;
    }
    if (register_id >= LGW_TOTALREGS) {
        DEBUG_MSG("ERROR: REGISTER NUMBER OUT OF DEFINED RANGE\n");
        return LGW_REG_ERROR;
    }
    
    /* check if SPI is initialised */
    if ((lgw_spidesc < 0) || (lgw_regpage < 0)) {
        DEBUG_MSG("ERROR: GATEWAY UNCONNECTED\n");
        return LGW_REG_ERROR;
    }
    
    /* get register struct from the struct array */
    r = loregs[register_id];
    
    /* reject write to read-only registers */
    if (r.rdon == 1){
        DEBUG_MSG("ERROR: TRYING TO BURST WRITE A READ-ONLY REGISTER\n");
        return LGW_REG_ERROR;
    }
    
    /* select proper register page if needed */
    if ((r.page != -1) && (r.page != lgw_regpage)) {
        spi_stat += page_switch(r.page);
    }
    
    /* do the burst write */
    spi_stat = lgw_spi_wb(lgw_spidesc, r.addr, data, size);
    
    if (spi_stat != LGW_SPI_SUCCESS) {
        DEBUG_MSG("ERROR: SPI ERROR DURING REGISTER BURST WRITE\n");
        return LGW_REG_ERROR;
    } else {
        return LGW_REG_SUCCESS;
    }
}

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

/* Point to a register by name and do a burst read */
int lgw_reg_rb(uint16_t register_id, uint8_t *data, uint16_t size) {
    int spi_stat;
    struct lgw_reg_s r;
    
    /* check input parameters */
    CHECK_NULL(data);
    if (size == 0) {
        DEBUG_MSG("ERROR: BURST OF NULL LENGTH\n");
        return LGW_REG_ERROR;
    }
    if (register_id >= LGW_TOTALREGS) {
        DEBUG_MSG("ERROR: REGISTER NUMBER OUT OF DEFINED RANGE\n");
        return LGW_REG_ERROR;
    }
    
    /* check if SPI is initialised */
    if ((lgw_spidesc < 0) || (lgw_regpage < 0)) {
        DEBUG_MSG("ERROR: GATEWAY UNCONNECTED\n");
        return LGW_REG_ERROR;
    }
    
    /* get register struct from the struct array */
    r = loregs[register_id];
    
    /* select proper register page if needed */
    if ((r.page != -1) && (r.page != lgw_regpage)) {
        spi_stat += page_switch(r.page);
    }
    
    /* do the burst read */
    spi_stat = lgw_spi_rb(lgw_spidesc, r.addr, data, size);
    
    if (spi_stat != LGW_SPI_SUCCESS) {
        DEBUG_MSG("ERROR: SPI ERROR DURING REGISTER BURST READ\n");
        return LGW_REG_ERROR;
    } else {
        return LGW_REG_SUCCESS;
    }
}

/* --- EOF ------------------------------------------------------------------ */
